use nalgebra::{PerspectiveMatrix3, Isometry3, Point3, Vector3, Rotation,
                Translation, Matrix4, Eye};
use glium::{DrawParameters, Depth, DepthTest, VertexBuffer, IndexBuffer,
            Program, Texture2d};
use glium::texture::MipmapsOption;
use glium::Surface;
use glium::texture::depth_texture2d::DepthTexture2d;
use glium::backend::glutin_backend::GlutinFacade;
use glium::framebuffer::SimpleFrameBuffer;
use glium::Blend;
use glium::index::{NoIndices, PrimitiveType};
use glium::backend::Facade;
use nalgebra::ToHomogeneous;
use particles::Particles;

const PARTICLES_VERT: &'static str = include_str!("shaders/particles.vert");
const PARTICLES_FRAG: &'static str = include_str!("shaders/particles.frag");
const PARTICLES_GEOM: &'static str = include_str!("shaders/particles.geom");

const BLUR_QUAD_VERT: &'static str = include_str!("shaders/blur_quad.vert");
const BLUR_QUAD_FRAG: &'static str = include_str!("shaders/blur_quad.frag");

const CIRCLE_VERT: &'static str = include_str!("shaders/circle.vert");
const CIRCLE_FRAG: &'static str = include_str!("shaders/circle.frag");

// const BACKGROUND: (f32, f32, f32, f32) = (0.17578, 0.17578, 0.17578, 1.0); // sRGB
const BACKGROUND: (f32, f32, f32, f32) = (0.026, 0.026, 0.026, 1.0); // ???

const CIRCLE_DIAMETER: f32 = 0.002;

#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
    tex_coords: [f32; 2],
}

implement_vertex!(Vertex, position, tex_coords);

struct Screen {
    width: f32,
    height: f32
}

struct BlurQuad<'a> {
    draw_parameters: DrawParameters<'a>,
    vertex_buffer: VertexBuffer<Vertex>,
    indices: IndexBuffer<u16>,
    program: Program
}

struct DepthSteps<'a> {
    draw_parameters: DrawParameters<'a>,
    indices: NoIndices,
    program: Program,
    circle_texture: Texture2d,
    col_depth_texture: Texture2d,
    depth_texture: DepthTexture2d
}

pub struct Camera<'a> {
    projection: PerspectiveMatrix3<f32>,
    view: Isometry3<f32>,
    blur_quad: BlurQuad<'a>,
    depth_steps: DepthSteps<'a>,
    screen: Screen,
}

impl<'a> Camera<'a> {
    pub fn new<F: Facade>(facade: &F, width: f32, height: f32) -> Camera<'a> {
        let eye_pos = Point3::new(1.0, -0.25, -0.5); // FIXME store this somewhere
        let target = Point3::new(0.0, 0.0, 0.0);

        // building the index buffer
        let bq_index_buffer = IndexBuffer::new(facade, PrimitiveType::TriangleStrip,
                                &[1 as u16, 2, 0, 3]).unwrap();

        // building the vertex buffer, which contains all the vertices that we will draw
        let bq_vertex_buffer = VertexBuffer::new(facade, &[
                    Vertex { position: [-1.0, -1.0], tex_coords: [0.0, 0.0] },
                    Vertex { position: [-1.0,  1.0], tex_coords: [0.0, 1.0] },
                    Vertex { position: [ 1.0,  1.0], tex_coords: [1.0, 1.0] },
                    Vertex { position: [ 1.0, -1.0], tex_coords: [1.0, 0.0] } ]).unwrap();

        let bq_draw_parameters = DrawParameters {
            // blend: Blend::alpha_blending(),
            .. Default::default()
        };

        let blur_quad = BlurQuad {
            draw_parameters: bq_draw_parameters,
            vertex_buffer: bq_vertex_buffer, // give this each time drawing
            indices: bq_index_buffer,
            program: Program::from_source(facade, BLUR_QUAD_VERT, BLUR_QUAD_FRAG, None).unwrap()
        };

        let dt_draw_parameters = DrawParameters {
            depth: Depth {
                test: DepthTest::IfLess,
                write: true,
                // range: (0.0, 1.0), // not working ???
                .. Default::default()
            },
            .. Default::default()
        };

        let col_depth_texture;
        let depth_texture;
        let circle_texture;
        {
            let (width, height) = (width as u32, height as u32);
            col_depth_texture = Texture2d::empty(facade, width, height).unwrap();
            depth_texture = DepthTexture2d::empty(facade, width, height).unwrap();

            let (circle_width, circle_height) = (256, 256);
            // let mipmap_opt = MipmapsOption::AutoGeneratedMipmaps; // need to be activated
            let mipmap_opt = MipmapsOption::NoMipmap;
            circle_texture = Texture2d::empty_with_mipmaps(facade, mipmap_opt, circle_width, circle_height).unwrap();
            println!("circle texture mipmaps level {:?}", circle_texture.get_mipmap_levels());

            // FIXME reuse the vertex_buffer above
            let vertex_buffer = VertexBuffer::new(facade, &[
                    Vertex { position: [-1.0, -1.0], tex_coords: [0.0, 0.0] },
                    Vertex { position: [-1.0,  1.0], tex_coords: [0.0, 1.0] },
                    Vertex { position: [ 1.0,  1.0], tex_coords: [1.0, 1.0] },
                    Vertex { position: [ 1.0, -1.0], tex_coords: [1.0, 0.0] } ]).unwrap();

            // FIXME IDEM
            let index_buffer = IndexBuffer::new(facade, PrimitiveType::TriangleStrip,
                                &[1 as u16, 2, 0, 3]).unwrap();

            let program = Program::from_source(facade, CIRCLE_VERT, CIRCLE_FRAG, None).unwrap();
            let mut circle_surface = circle_texture.as_surface();
            circle_surface.clear_color(0.0, 0.0, 0.0, 0.0);
            let uniforms = uniform! {
                matrix: *Matrix4::<f32>::new_identity(4).as_ref(),
                circle_diameter: CIRCLE_DIAMETER,
                resolution: [circle_width as f32, circle_height as f32]
            };
            circle_surface.draw(&vertex_buffer, &index_buffer, &program,
                    &uniforms, &Default::default()).unwrap();
        }

        let depth_steps = DepthSteps {
            draw_parameters: dt_draw_parameters,
            indices: NoIndices(PrimitiveType::Points),
            program: Program::from_source(facade, PARTICLES_VERT, PARTICLES_FRAG,
                        Some(PARTICLES_GEOM)).unwrap(),
            circle_texture: circle_texture,
            col_depth_texture: col_depth_texture,
            depth_texture: depth_texture
        };

        Camera {
            projection: PerspectiveMatrix3::new(width / height, 60.5, 0.001, 3.0),
            view: Isometry3::look_at_rh(&eye_pos, &target, &Vector3::new(0.0, 1.0, 0.0)),
            screen: Screen{ width: width, height: height },
            blur_quad: blur_quad,
            depth_steps: depth_steps
        }
    }

    pub fn draw(&self, facade: &GlutinFacade, particles: &Particles, time: f32) {
        let col_depth_texture = &self.depth_steps.col_depth_texture;
        let depth_texture = &self.depth_steps.depth_texture;
        let mut frame_texture = SimpleFrameBuffer::with_depth_buffer(facade,
                                    col_depth_texture, depth_texture).unwrap();

        let mut frame = (*facade).draw();
        frame.clear_color_srgb_and_depth(BACKGROUND, 1.0);
        frame_texture.clear_color_srgb_and_depth((0.0, 0.0, 1.0, 1.0), 1.0); // FIXME clear with another color

        let mut projection = self.projection;
        // let view = ;
        let mut view = self.view;
        let angle = Vector3::new(0.0, time.cos() / 3.0, 0.0);
        view = view.prepend_rotation(&angle);

        // projection.set_zfar(1.0 + (time.cos() + 1.0));
        // println!("projection: {:?}", projection);
        // let fov = 60.0 + ((time / 5.0).sin()) + 1.0;
        // println!("fov {:?}", fov);
        // projection.set_fovy(fov);

        let matrix = (*projection.as_matrix()) * (view.to_homogeneous());
        let depth_steps_uniforms = uniform!{ // FIXME rename this
            matrix: *matrix.as_ref(),
            eye_pos: *(view.translation().as_ref()),
            znear: projection.znear(),
            zfar: projection.zfar(),
            resolution: [self.screen.width, self.screen.height],
            circle_diameter: CIRCLE_DIAMETER,
            circle_texture: &self.depth_steps.circle_texture,
            // circle_texture: self.depth_steps.circle_texture.mipmap(0).unwrap().get_texture()
        };
        frame_texture.draw(particles.positions(), &self.depth_steps.indices,
            &self.depth_steps.program, &depth_steps_uniforms,
            &self.depth_steps.draw_parameters).unwrap();

        let blur_quad_uniforms = uniform! {
            matrix: *Matrix4::<f32>::new_identity(4).as_ref(),
            col_depth_tex: col_depth_texture,
            resolution: [self.screen.width, self.screen.height],
            time: time
        };
        frame.draw(&self.blur_quad.vertex_buffer, &self.blur_quad.indices,
            &self.blur_quad.program, &blur_quad_uniforms,
            &self.blur_quad.draw_parameters).unwrap();

        // println!("time: {:?}", time);

        frame.finish().unwrap();
    }
}
